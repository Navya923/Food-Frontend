{"ast":null,"code":"import { __assign, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, assign, classNamesFunction, css, getFirstFocusable, getLastFocusable, getRTL, KeyCodes, shouldWrapFocus, isIOS, isMac, memoizeFunction, getPropsWithDefaults, getDocument } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { useTarget, usePrevious, useAsync, useWarnings, useId } from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction(); // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\nvar DEFAULT_PROPS = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16\n};\nexport function getSubmenuItems(item, options) {\n  var target = options === null || options === void 0 ? void 0 : options.target; // eslint-disable-next-line deprecation/deprecation\n\n  var items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    var overrideItems = [];\n\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n      var subItem = items_1[_i];\n\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        var onClick = subItem.onClick,\n            contextItem = __rest(subItem, [\"onClick\"]);\n\n        overrideItems.push(__assign(__assign({}, contextItem), {\n          onClick: getOnClickWithOverrideTarget(onClick, target)\n        }));\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250;\n/* ms */\n\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles));\n  };\n}); //#region Custom hooks\n\n\nfunction useVisibility(props, targetWindow) {\n  var _a = props.hidden,\n      hidden = _a === void 0 ? false : _a,\n      onMenuDismissed = props.onMenuDismissed,\n      onMenuOpened = props.onMenuOpened;\n  var previousHidden = usePrevious(hidden);\n  var onMenuOpenedRef = React.useRef(onMenuOpened);\n  var onMenuClosedRef = React.useRef(onMenuDismissed);\n  var propsRef = React.useRef(props);\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n  React.useEffect(function () {\n    var _a, _b; // Don't issue dismissed callbacks on initial mount\n\n\n    if (hidden && previousHidden === false) {\n      (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);\n    }\n  }, [hidden, previousHidden]); // Issue onDismissedCallback on unmount\n\n  React.useEffect(function () {\n    return function () {\n      var _a;\n\n      return (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    };\n  }, []);\n}\n\nfunction useSubMenuState(_a, dismiss) {\n  var hidden = _a.hidden,\n      items = _a.items,\n      theme = _a.theme,\n      className = _a.className,\n      id = _a.id,\n      menuTarget = _a.target;\n\n  var _b = React.useState(),\n      expandedMenuItemKey = _b[0],\n      setExpandedMenuItemKey = _b[1];\n\n  var _c = React.useState(),\n      submenuTarget = _c[0],\n      setSubmenuTarget = _c[1];\n\n  var subMenuId = useId(COMPONENT_NAME, id);\n  var closeSubMenu = React.useCallback(function () {\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n  var openSubMenu = React.useCallback(function (_a, target) {\n    var submenuItemKey = _a.key;\n\n    if (expandedMenuItemKey === submenuItemKey) {\n      return;\n    }\n\n    target.focus();\n    setExpandedMenuItemKey(submenuItemKey);\n    setSubmenuTarget(target);\n  }, [expandedMenuItemKey]);\n  React.useEffect(function () {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  var getSubmenuProps = function () {\n    var item = findItemByKeyFromItems(expandedMenuItemKey, items);\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item, {\n          target: menuTarget\n        }),\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        var onItemClick = item.onItemClick;\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];\n}\n\nfunction useShouldUpdateFocusOnMouseMove(_a) {\n  var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover,\n      hidden = _a.hidden;\n  var shouldUpdateFocusOnMouseEvent = React.useRef(!delayUpdateFocusOnHover);\n  var gotMouseMove = React.useRef(false);\n  React.useEffect(function () {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n  var onMenuFocusCapture = React.useCallback(function () {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = false;\n    }\n  }, [delayUpdateFocusOnHover]);\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];\n}\n\nfunction usePreviousActiveElement(_a, targetWindow) {\n  var hidden = _a.hidden,\n      onRestoreFocus = _a.onRestoreFocus;\n  var previousActiveElement = React.useRef();\n  var tryFocusPreviousActiveElement = React.useCallback(function (options) {\n    var _a, _b;\n\n    if (onRestoreFocus) {\n      onRestoreFocus(options);\n    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {\n      // Make sure that the focus method actually exists\n      // In some cases the object might exist but not be a real element.\n      // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n      (_b = (_a = previousActiveElement.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }, [onRestoreFocus]); // eslint-disable-next-line no-restricted-properties\n\n  React.useLayoutEffect(function () {\n    var _a;\n\n    if (!hidden) {\n      previousActiveElement.current = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;\n    } else if (previousActiveElement.current) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousActiveElement.current,\n        containsFocus: true,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n      previousActiveElement.current = undefined;\n    }\n  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);\n  return [tryFocusPreviousActiveElement];\n}\n\nfunction useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {\n  var theme = _a.theme,\n      isSubMenu = _a.isSubMenu,\n      _b = _a.focusZoneProps,\n      _c = _b === void 0 ? {} : _b,\n      checkForNoWrap = _c.checkForNoWrap,\n      _d = _c.direction,\n      focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n\n\n  var lastKeyDownWasAltOrMeta = React.useRef();\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n\n  var keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n    var handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n  /**\n   * Checks if the submenu should be closed\n   */\n\n\n  var shouldCloseSubMenu = function (ev) {\n    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left; // eslint-disable-next-line deprecation/deprecation\n\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap'));\n  };\n\n  var shouldHandleKeyDown = function (ev) {\n    return (// eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)\n    );\n  };\n\n  var onKeyDown = function (ev) {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n\n    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n\n\n  var shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  var onKeyUp = function (ev) {\n    return keyHandler(ev, shouldHandleKeyUp, true\n    /* dismissAllMenus */\n    );\n  };\n\n  var onMenuKeyDown = function (ev) {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    var handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    } // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n\n\n    var hasModifier = !!(ev.altKey || ev.metaKey); // eslint-disable-next-line deprecation/deprecation\n\n    var isUp = ev.which === KeyCodes.up; // eslint-disable-next-line deprecation/deprecation\n\n    var isDown = ev.which === KeyCodes.down;\n\n    if (!hasModifier && (isUp || isDown)) {\n      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  var onItemKeyDown = function (item, ev) {\n    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (!item.disabled && ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n      openSubMenu(item, ev.currentTarget, false);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];\n}\n\nfunction useScrollHandler(asyncTracker) {\n  var isScrollIdle = React.useRef(true);\n  var scrollIdleTimeoutId = React.useRef();\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n\n  var onScroll = function () {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function () {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle];\n}\n\nfunction useOnSubmenuDismiss(dismiss, closeSubMenu) {\n  var isMountedRef = React.useRef(false);\n  React.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n\n  var onSubMenuDismiss = function (ev, dismissAll) {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer(_a, asyncTracker) {\n  var _b = _a.subMenuHoverDelay,\n      subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;\n  var enterTimerRef = React.useRef(undefined);\n\n  var cancelSubMenuTimer = function () {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  var startSubmenuTimer = function (onTimerExpired) {\n    enterTimerRef.current = asyncTracker.setTimeout(function () {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];\n}\n\nfunction useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {\n  var menuTarget = props.target;\n\n  var onItemMouseEnterBase = function (item, ev, target) {\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    }\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var onItemMouseMoveBase = function (item, ev, target) {\n    var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (!isScrollIdle.current || subMenuEntryTimer.current !== undefined || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var shouldIgnoreMouseEvent = function () {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  var onMouseItemLeave = function (item, ev) {\n    var _a;\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n\n\n    if (hostElement.current.setActive) {\n      try {\n        hostElement.current.setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  var updateFocusOnMouseEvent = function (item, ev, target) {\n    var targetElement = target ? target : ev.currentTarget;\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer(); // If the menu is not expanded we can update focus without any delay\n\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(function () {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(function () {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  var onItemClick = function (item, ev) {\n    onItemClickBase(item, ev, ev.currentTarget);\n  };\n\n  var onItemClickBase = function (item, ev, target) {\n    var items = getSubmenuItems(item, {\n      target: menuTarget\n    }); // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        openSubMenu(item, target, // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n        // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n        // between a real click event and a keypress event (detail should be the number of mouse clicks).\n        // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n        // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n        // and \"\" for pressing \"Enter\" with Narrator on.\n        ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse');\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  var onAnchorClick = function (item, ev) {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  var executeItemClick = function (item, ev) {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    var shouldDismiss = false;\n\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [onItemMouseEnterBase, onItemMouseMoveBase, onMouseItemLeave, onItemClick, onAnchorClick, executeItemClick, onItemClickBase];\n} //#endregion\n\n\nexport var ContextualMenuBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a;\n\n  var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n      ref = _b.ref,\n      props = __rest(_b, [\"ref\"]);\n\n  var hostElement = React.useRef(null);\n  var asyncTracker = useAsync();\n  var menuId = useId(COMPONENT_NAME, props.id);\n  useWarnings({\n    name: COMPONENT_NAME,\n    props: props,\n    deprecations: {\n      getMenuClassNames: 'styles'\n    }\n  });\n\n  var dismiss = function (ev, dismissAll) {\n    var _a;\n\n    return (_a = props.onDismiss) === null || _a === void 0 ? void 0 : _a.call(props, ev, dismissAll);\n  };\n\n  var _c = useTarget(props.target, hostElement),\n      targetRef = _c[0],\n      targetWindow = _c[1];\n\n  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];\n\n  var _d = useSubMenuState(props, dismiss),\n      expandedMenuItemKey = _d[0],\n      openSubMenu = _d[1],\n      getSubmenuProps = _d[2],\n      onSubMenuDismiss = _d[3];\n\n  var _e = useShouldUpdateFocusOnMouseMove(props),\n      shouldUpdateFocusOnMouseEvent = _e[0],\n      gotMouseMove = _e[1],\n      onMenuFocusCapture = _e[2];\n\n  var _f = useScrollHandler(asyncTracker),\n      onScroll = _f[0],\n      isScrollIdle = _f[1];\n\n  var _g = useSubmenuEnterTimer(props, asyncTracker),\n      cancelSubMenuTimer = _g[0],\n      startSubmenuTimer = _g[1],\n      subMenuEntryTimer = _g[2];\n\n  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n  useVisibility(props, targetWindow);\n\n  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu),\n      onKeyDown = _h[0],\n      onKeyUp = _h[1],\n      onMenuKeyDown = _h[2],\n      onItemKeyDown = _h[3];\n\n  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss),\n      onItemMouseEnterBase = _j[0],\n      onItemMouseMoveBase = _j[1],\n      onMouseItemLeave = _j[2],\n      onItemClick = _j[3],\n      onAnchorClick = _j[4],\n      executeItemClick = _j[5],\n      onItemClickBase = _j[6]; //#region Render helpers\n\n\n  var onDefaultRenderMenuList = function (menuListProps, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, defaultRender) {\n    var indexCorrection = 0;\n    var items = menuListProps.items,\n        totalItemCount = menuListProps.totalItemCount,\n        hasCheckmarks = menuListProps.hasCheckmarks,\n        hasIcons = menuListProps.hasIcons;\n    return React.createElement(\"ul\", {\n      className: menuClassNames.list,\n      onKeyDown: onKeyDown,\n      onKeyUp: onKeyUp,\n      role: 'presentation'\n    }, items.map(function (item, index) {\n      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        indexCorrection += indexIncrease;\n      }\n\n      return menuItem;\n    }));\n  };\n\n  var renderFocusZone = function (children, adjustedFocusZoneProps) {\n    var _a = props.focusZoneAs,\n        ChildrenRenderer = _a === void 0 ? FocusZone : _a;\n    return React.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps), children);\n  };\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n\n\n  var renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var _a;\n\n    var renderedItems = [];\n    var iconProps = item.iconProps || {\n      iconName: 'None'\n    };\n    var getItemClassNames = item.getItemClassNames,\n        // eslint-disable-line deprecation/deprecation\n    itemProps = item.itemProps;\n    var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n\n    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n    var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n    } else {\n      var itemStyleProps = {\n        theme: props.theme,\n        disabled: isItemDisabled(item),\n        expanded: expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName: dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      }; // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n\n      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = menuClassNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n    } // eslint-disable-next-line deprecation/deprecation\n\n\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        break;\n\n      case ContextualMenuItemType.Header:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n\n      case ContextualMenuItemType.Section:\n        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n        break;\n\n      default:\n        var menuItem = renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n    return React.createElement(React.Fragment, {\n      key: item.key\n    }, renderedItems);\n  };\n\n  var defaultMenuItemRenderer = function (item, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var index = item.index,\n        focusableElementIndex = item.focusableElementIndex,\n        totalItemCount = item.totalItemCount,\n        hasCheckmarks = item.hasCheckmarks,\n        hasIcons = item.hasIcons;\n    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n  };\n\n  var renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabelledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id_1 = menuId + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id_1\n        };\n        ariaLabelledby = id_1;\n      } else {\n        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), {\n          id: id_2\n        });\n        ariaLabelledby = id_2;\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabelledby\n        };\n        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: menuClassNames.list,\n        role: \"presentation\"\n      }, sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true), headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons, menuClassNames);\n      }), sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true))));\n    }\n  };\n\n  var renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  var renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  var renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), dismiss);\n    }\n\n    var contextualMenuItemAs = props.contextualMenuItemAs;\n    var commonProps = {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: onItemMouseEnterBase,\n      onItemMouseLeave: onMouseItemLeave,\n      onItemMouseMove: onItemMouseMoveBase,\n      onItemMouseDown: onItemMouseDown,\n      executeItemClick: executeItemClick,\n      onItemKeyDown: onItemKeyDown,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: openSubMenu,\n      dismissSubMenu: onSubMenuDismiss,\n      dismissMenu: dismiss\n    };\n\n    if (item.href) {\n      return React.createElement(ContextualMenuAnchor, __assign({}, commonProps, {\n        onItemClick: onAnchorClick\n      }));\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return React.createElement(ContextualMenuSplitButton, __assign({}, commonProps, {\n        onItemClick: onItemClick,\n        onItemClickBase: onItemClickBase,\n        onTap: cancelSubMenuTimer\n      }));\n    }\n\n    return React.createElement(ContextualMenuButton, __assign({}, commonProps, {\n      onItemClick: onItemClick,\n      onItemClickBase: onItemClickBase\n    }));\n  };\n\n  var renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _a = props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: menuClassNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: itemClassNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  }; //#endregion\n  //#region Main render\n\n\n  var isBeakVisible = props.isBeakVisible;\n  var items = props.items,\n      labelElementId = props.labelElementId,\n      id = props.id,\n      className = props.className,\n      beakWidth = props.beakWidth,\n      directionalHint = props.directionalHint,\n      directionalHintForRTL = props.directionalHintForRTL,\n      alignTargetEdge = props.alignTargetEdge,\n      gapSpace = props.gapSpace,\n      coverTarget = props.coverTarget,\n      ariaLabel = props.ariaLabel,\n      doNotLayer = props.doNotLayer,\n      target = props.target,\n      bounds = props.bounds,\n      useTargetWidth = props.useTargetWidth,\n      useTargetAsMinWidth = props.useTargetAsMinWidth,\n      directionalHintFixed = props.directionalHintFixed,\n      shouldFocusOnMount = props.shouldFocusOnMount,\n      shouldFocusOnContainer = props.shouldFocusOnContainer,\n      title = props.title,\n      styles = props.styles,\n      theme = props.theme,\n      calloutProps = props.calloutProps,\n      _k = props.onRenderSubMenu,\n      onRenderSubMenu = _k === void 0 ? onDefaultRenderSubMenu : _k,\n      _l = props.onRenderMenuList,\n      onRenderMenuList = _l === void 0 ? function (menuListProps, defaultRender) {\n    return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n  } : _l,\n      focusZoneProps = props.focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n  getMenuClassNames = props.getMenuClassNames;\n  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n    theme: theme,\n    className: className\n  });\n  var hasIcons = itemsHaveIcons(items);\n\n  function itemsHaveIcons(contextualMenuItems) {\n    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n      var item = contextualMenuItems_1[_i];\n\n      if (item.iconProps) {\n        return true;\n      }\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var adjustedFocusZoneProps = __assign(__assign({\n    direction: FocusZoneDirection.vertical,\n    handleTabKey: FocusZoneTabbableElements.all,\n    isCircularNavigation: true\n  }, focusZoneProps), {\n    className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className)\n  });\n\n  var hasCheckmarks = canAnyMenuItemsCheck(items);\n  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n  isBeakVisible = isBeakVisible === undefined ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n  /**\n   * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n   */\n\n  var contextMenuStyle;\n  var targetAsHtmlElement = targetRef.current;\n\n  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n    var targetWidth = targetBoundingRect.width - 2;\n    /* Accounts for 1px border */\n\n    if (useTargetWidth) {\n      contextMenuStyle = {\n        width: targetWidth\n      };\n    } else if (useTargetAsMinWidth) {\n      contextMenuStyle = {\n        minWidth: targetWidth\n      };\n    }\n  } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n  if (items && items.length > 0) {\n    var totalItemCount_1 = 0;\n\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        totalItemCount_1 += itemCount;\n      }\n    }\n\n    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : undefined;\n    return React.createElement(MenuContext.Consumer, null, function (menuContext) {\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles_1,\n        onRestoreFocus: tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target || menuContext.target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: props.onDismiss || menuContext.onDismiss,\n        onScroll: onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: props.hidden || menuContext.hidden,\n        ref: forwardedRef\n      }), React.createElement(\"div\", {\n        style: contextMenuStyle,\n        ref: hostElement,\n        id: id,\n        className: classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: onMenuKeyDown,\n        onKeyUp: onKeyUp,\n        onFocusCapture: onMenuFocusCapture,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        role: 'menu'\n      }, title && React.createElement(\"div\", {\n        className: classNames.title\n      }, \" \", title, \" \"), items && items.length ? renderFocusZone(onRenderMenuList({\n        ariaLabel: ariaLabel,\n        items: items,\n        totalItemCount: totalItemCount_1,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: function (item) {\n          return defaultMenuItemRenderer(item, classNames);\n        },\n        labelElementId: labelElementId\n      }, function (menuListProps, defaultRender) {\n        return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n      }), adjustedFocusZoneProps) : null, submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)));\n    });\n  } else {\n    return null;\n  } //#endregion\n\n}), function (prevProps, newProps) {\n  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(prevProps, newProps);\n});\nContextualMenuBase.displayName = 'ContextualMenuBase';\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\n\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item, ev) {\n  var _a;\n\n  (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);\n}\n\nfunction onDefaultRenderSubMenu(subMenuProps, defaultRender) {\n  throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n}\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\n\n\nfunction findItemByKeyFromItems(key, items) {\n  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {\n    var item = items_3[_i];\n\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      var match = findItemByKeyFromItems(key, item.sectionProps.items);\n\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(onClick, target) {\n  return onClick ? function (ev, item) {\n    overrideTarget(ev, target);\n    return onClick(ev, item);\n  } : onClick;\n}\n\nfunction overrideTarget(ev, target) {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}