{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { css, divProperties, elementContains, focusFirstChild, getNativeProps, on, shallowCompare, getPropsWithDefaults } from '../../Utilities';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nvar COMPONENT_NAME = 'CalloutContentBase';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n}; // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\n\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n}; // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\n\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\nvar DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\nvar getClassNames = classNamesFunction({\n  disableCaching: true // disabling caching because stylesProp.position mutates often\n\n});\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\n\nfunction useBounds(_a, targetRef, targetWindow) {\n  var bounds = _a.bounds,\n      _b = _a.minPagePadding,\n      minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b,\n      target = _a.target;\n\n  var _c = React.useState(false),\n      targetWindowResized = _c[0],\n      setTargetWindowResized = _c[1];\n\n  var cachedBounds = React.useRef();\n  var getBounds = React.useCallback(function () {\n    if (!cachedBounds.current || targetWindowResized) {\n      var currentBounds = typeof bounds === 'function' ? targetWindow ? bounds(target, targetWindow) : undefined : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right - minPagePadding,\n          bottom: currentBounds.bottom - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2\n        };\n      }\n\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n  var async = useAsync();\n  useOnEvent(targetWindow, 'resize', async.debounce(function () {\n    setTargetWindowResized(true);\n  }, 500, {\n    leading: true\n  }));\n  return getBounds;\n}\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\n\n\nfunction useMaxHeight(_a, getBounds, positions) {\n  var _b;\n\n  var calloutMaxHeight = _a.calloutMaxHeight,\n      finalHeight = _a.finalHeight,\n      directionalHint = _a.directionalHint,\n      directionalHintFixed = _a.directionalHintFixed,\n      hidden = _a.hidden;\n\n  var _c = React.useState(),\n      maxHeight = _c[0],\n      setMaxHeight = _c[1];\n\n  var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {},\n      top = _d.top,\n      bottom = _d.bottom;\n\n  React.useEffect(function () {\n    var _a;\n\n    var _b = (_a = getBounds()) !== null && _a !== void 0 ? _a : {},\n        topBounds = _b.top,\n        bottomBounds = _b.bottom;\n\n    if (!calloutMaxHeight && !hidden) {\n      if (typeof top === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - top);\n      } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - topBounds - bottom);\n      }\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);\n  return maxHeight;\n}\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\n\n\nfunction usePositions(props, hostElement, calloutElement, targetRef, getBounds) {\n  var _a = React.useState(),\n      positions = _a[0],\n      setPositions = _a[1];\n\n  var positionAttempts = React.useRef(0);\n  var previousTarget = React.useRef();\n  var async = useAsync();\n  var hidden = props.hidden,\n      target = props.target,\n      finalHeight = props.finalHeight,\n      calloutMaxHeight = props.calloutMaxHeight,\n      onPositioned = props.onPositioned,\n      directionalHint = props.directionalHint;\n  React.useEffect(function () {\n    if (!hidden) {\n      var timerId_1 = async.requestAnimationFrame(function () {\n        var _a, _b;\n\n        if (hostElement.current && calloutElement) {\n          var currentProps = __assign(__assign({}, props), {\n            target: targetRef.current,\n            bounds: getBounds()\n          }); // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n\n\n          var dupeCalloutElement = calloutElement.cloneNode(true);\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? \"\" + calloutMaxHeight : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          (_a = calloutElement.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(dupeCalloutElement);\n          var previousPositions = previousTarget.current === target ? positions : undefined; // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n\n          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions); // clean up duplicate calloutElement\n\n          (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement); // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);\n          }\n        }\n      }, calloutElement);\n      previousTarget.current = target;\n      return function () {\n        async.cancelAnimationFrame(timerId_1);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [hidden, directionalHint, async, calloutElement, calloutMaxHeight, hostElement, targetRef, finalHeight, getBounds, onPositioned, positions, props, target]);\n  return positions;\n}\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\n\n\nfunction useAutoFocus(_a, positions, calloutElement) {\n  var hidden = _a.hidden,\n      setInitialFocus = _a.setInitialFocus;\n  var async = useAsync();\n  var hasPositions = !!positions;\n  React.useEffect(function () {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      var timerId_2 = async.requestAnimationFrame(function () {\n        return focusFirstChild(calloutElement);\n      }, calloutElement);\n      return function () {\n        return async.cancelAnimationFrame(timerId_2);\n      };\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\n\n\nfunction useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {\n  var hidden = _a.hidden,\n      onDismiss = _a.onDismiss,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnScroll = _a.preventDismissOnScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnResize = _a.preventDismissOnResize,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n      dismissOnTargetClick = _a.dismissOnTargetClick,\n      shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus,\n      preventDismissOnEvent = _a.preventDismissOnEvent;\n  var isMouseDownOnPopup = React.useRef(false);\n  var async = useAsync();\n  var mouseDownHandlers = useConst([function () {\n    isMouseDownOnPopup.current = true;\n  }, function () {\n    isMouseDownOnPopup.current = false;\n  }]);\n  var positionsExists = !!positions;\n  React.useEffect(function () {\n    var dismissOnScroll = function (ev) {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnResize = function (ev) {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnLostFocus = function (ev) {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnClickOrScroll = function (ev) {\n      var eventPaths = ev.composedPath ? ev.composedPath() : [];\n      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;\n      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target); // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || 'stopPropagation' in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnTargetWindowBlur = function (ev) {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    }; // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n\n\n    var disposablesPromise = new Promise(function (resolve) {\n      async.setTimeout(function () {\n        if (!hidden && targetWindow) {\n          var disposables_1 = [on(targetWindow, 'scroll', dismissOnScroll, true), on(targetWindow, 'resize', dismissOnResize, true), on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true), on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true), on(targetWindow, 'blur', dismissOnTargetWindowBlur, true)];\n          resolve(function () {\n            disposables_1.forEach(function (dispose) {\n              return dispose();\n            });\n          });\n        }\n      }, 0);\n    });\n    return function () {\n      disposablesPromise.then(function (dispose) {\n        return dispose();\n      });\n    };\n  }, [hidden, async, hostElement, targetRef, targetWindow, onDismiss, shouldDismissOnWindowFocus, dismissOnTargetClick, preventDismissOnLostFocus, preventDismissOnResize, preventDismissOnScroll, positionsExists, preventDismissOnEvent]);\n  return mouseDownHandlers;\n}\n\nexport var CalloutContentBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var styles = props.styles,\n      style = props.style,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      isBeakVisible = props.isBeakVisible,\n      children = props.children,\n      beakWidth = props.beakWidth,\n      calloutWidth = props.calloutWidth,\n      calloutMaxWidth = props.calloutMaxWidth,\n      calloutMinWidth = props.calloutMinWidth,\n      doNotLayer = props.doNotLayer,\n      finalHeight = props.finalHeight,\n      _a = props.hideOverflow,\n      hideOverflow = _a === void 0 ? !!finalHeight : _a,\n      backgroundColor = props.backgroundColor,\n      calloutMaxHeight = props.calloutMaxHeight,\n      onScroll = props.onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  _b = props.shouldRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n  shouldRestoreFocus = _b === void 0 ? true : _b,\n      target = props.target,\n      hidden = props.hidden,\n      onLayerMounted = props.onLayerMounted;\n  var hostElement = React.useRef(null);\n\n  var _c = React.useState(null),\n      calloutElement = _c[0],\n      setCalloutElement = _c[1];\n\n  var calloutCallback = React.useCallback(function (calloutEl) {\n    setCalloutElement(calloutEl);\n  }, []);\n  var rootRef = useMergedRefs(hostElement, forwardedRef);\n\n  var _d = useTarget(props.target, {\n    current: calloutElement\n  }),\n      targetRef = _d[0],\n      targetWindow = _d[1];\n\n  var getBounds = useBounds(props, targetRef, targetWindow);\n  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n  var maxHeight = useMaxHeight(props, getBounds, positions);\n\n  var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow),\n      mouseDownOnPopup = _e[0],\n      mouseUpOnPopup = _e[1]; // do not set both top and bottom css props from positions\n  // instead, use maxHeight\n\n\n  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);\n\n  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), {\n    maxHeight: maxHeight\n  });\n\n  if (isForcedInBounds) {\n    cssPositions.bottom = undefined;\n  }\n\n  useAutoFocus(props, positions, calloutElement);\n  React.useEffect(function () {\n    if (!hidden) {\n      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n\n  }, [hidden]); // If there is no target window then we are likely in server side rendering and we should not render anything.\n\n  if (!targetWindow) {\n    return null;\n  }\n\n  var overflowYHidden = hideOverflow;\n  var beakVisible = isBeakVisible && !!target;\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    overflowYHidden: overflowYHidden,\n    calloutWidth: calloutWidth,\n    positions: positions,\n    beakWidth: beakWidth,\n    backgroundColor: backgroundColor,\n    calloutMaxWidth: calloutMaxWidth,\n    calloutMinWidth: calloutMinWidth,\n    doNotLayer: doNotLayer\n  });\n\n  var overflowStyle = __assign(__assign({\n    maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%'\n  }, style), overflowYHidden && {\n    overflowY: 'hidden'\n  });\n\n  var visibilityStyle = props.hidden ? {\n    visibility: 'hidden'\n  } : undefined; // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n\n  return React.createElement(\"div\", {\n    ref: rootRef,\n    className: classNames.container,\n    style: visibilityStyle\n  }, React.createElement(\"div\", __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n    className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n    style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: calloutCallback\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beak,\n    style: getBeakPosition(positions)\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beakCurtain\n  }), React.createElement(Popup // don't use getNativeElementProps for role and roledescription because it will also\n  // pass through data-* props (resulting in them being used in two places)\n  , {\n    // don't use getNativeElementProps for role and roledescription because it will also\n    // pass through data-* props (resulting in them being used in two places)\n    role: props.role,\n    \"aria-roledescription\": props['aria-roledescription'],\n    ariaDescribedBy: ariaDescribedBy,\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    className: classNames.calloutMain,\n    onDismiss: props.onDismiss,\n    onMouseDown: mouseDownOnPopup,\n    onMouseUp: mouseUpOnPopup,\n    onRestoreFocus: props.onRestoreFocus,\n    onScroll: onScroll,\n    shouldRestoreFocus: shouldRestoreFocus,\n    style: overflowStyle\n  }, children)));\n}), function (previousProps, nextProps) {\n  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(previousProps, nextProps);\n});\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\n\nfunction getBeakPosition(positions) {\n  var _a, _b;\n\n  var beakPositionStyle = __assign(__assign({}, (_a = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a === void 0 ? void 0 : _a.elementPosition), {\n    display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? 'none' : undefined\n  });\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\n\n\nfunction arePositionsEqual(prevElementPositions, newElementPosition) {\n  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);\n}\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\n\n\nfunction comparePositions(prevElementPositions, newElementPositions) {\n  for (var key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = prevElementPositions[key];\n      var newPositionEdge = newElementPositions[key];\n\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nCalloutContentBase.displayName = COMPONENT_NAME;","map":null,"metadata":{},"sourceType":"module"}